---
title: "Joint RPCA Reproducible Example"
format: html
editor: visual
---

```{r setup, message=FALSE, warning=FALSE}
options(warn = -1)
# Load user-defined functions
source("../R/dependencies.R")
source("../R/jointRPCA.R")
source("../R/jointRPCAuniversal.R")
source("../R/jointOptspaceHelper.R")
source("../R/jointOptspaceSolve.R")
source("../R/optspaceHelper.R")
source("../R/transformHelper.R")
source("../R/transform.R")
source("../R/maskValueOnly.R")
source("../R/rpcaTableProcessing.R")
source("../R/jointRPCAutils.R")

# Load Data and Run Joint RPCA

# Example using MAE from mia::HintikkaXOData

#load example data
data(HintikkaXOData)

#run joint RPCA on MultiAssayExperiment object
result <- jointRPCAuniversal(
  data = HintikkaXOData,
  n.components = 3,
  train.test.column = "Set",
  rclr.transform.tables = TRUE,
  max.iterations = 5
)

# Compute and Store Sample Scores

#compute dataset-specific sample scores
rclr.tables <- result$rclr.tables
dataset_specific_scores <- .dataset_specific_scores(rclr.tables, n.components = 3, max.iterations = 5)

#store dataset-specific sample scores per experiment
for (i in seq_along(dataset_specific_scores)) {
  experiment_name <- names(HintikkaXOData)[i]
  reducedDim(HintikkaXOData[[experiment_name]], "localRPCA") <- dataset_specific_scores[[i]]
}

#view dataset-specific sample scores
for (name in names(HintikkaXOData)) {
  cat("\nSample Scores for:", name, "\n")
  print(head(reducedDim(HintikkaXOData[[name]], "localRPCA")))
}

#store joint RPCA sample scores in taxonomic experiment
reducedDim(HintikkaXOData[["microbiota"]], "jointRPCA") <- result$ord.res$samples

#view joint RPCA sample scores
head(reducedDim(HintikkaXOData[["microbiota"]], "jointRPCA"))

# Compute and Store Feature Loadings

#compute dataset-specific feature loadings
dataset_specific_loadings <- .dataset_specific_loadings(rclr.tables, n.components = 3, max.iterations = 5)

#store dataset-specific feature loadings per experiment
for (i in seq_along(dataset_specific_loadings)) {
  experiment_name <- names(HintikkaXOData)[i]
  metadata(HintikkaXOData[[experiment_name]])$localRPCA_feature_loadings <- dataset_specific_loadings[[i]]
}

#view dataset-specific feature loadings per experiment
for (name in names(HintikkaXOData)) {
  cat("\nFeature Loadings for:", name, "\n")
  print(head(metadata(HintikkaXOData[[name]])$localRPCA_feature_loadings))
}

#store joint feature loadings
metadata(HintikkaXOData[["microbiota"]])$jointRPCA_feature_loadings <- result$ord.res$features

#view joint feature loadings
head(metadata(HintikkaXOData[["microbiota"]])$jointRPCA_feature_loadings)

# Benchmarking

# 1) Choose/derive labels (factor) --------------------------------------------
labels <- as.factor(colData(HintikkaXOData)$Diet)

# 2) Build a common sample index across all feature sets ----------------------
#    (joint scores and rclr tables share rownames)
rn_joint <- rownames(result$ord.res$samples)
rn_rclr  <- lapply(result$rclr.tables, rownames)
common_samples <- Reduce(intersect, lapply(result$rclr.tables, colnames))

# subset labels to common samples
labels <- droplevels(labels[common_samples])

# 3) Feature sets --------------------------------------------------------------
# 3a) Joint-RPCA (shared sample embedding)
features_jointRPCA <- result$ord.res$samples[common_samples, , drop = FALSE]

# 3b) Per-layer RPCA sample scores, then concatenate
dataset_specific_scores_aligned <- lapply(dataset_specific_scores, function(M) {
  M[common_samples, , drop = FALSE]
})
features_rpca_concat <- do.call(cbind, dataset_specific_scores_aligned)

# 3c) Per-layer PCA sample scores, then concatenate (K PCs per layer)
K_pcs <- 3
dataset_specific_pca_scores <- lapply(result$rclr.tables, function(tbl) {
  tbl <- tbl[common_samples, , drop = FALSE]
  pca <- prcomp(tbl, center = TRUE, scale. = TRUE)
  pca$x[, seq_len(min(K_pcs, ncol(pca$x))), drop = FALSE]
})
features_pca_concat <- do.call(cbind, dataset_specific_pca_scores)

# 3d) Concatenated rCLR across layers -> PCA (global PCA baseline)
features_rclr_concat <- do.call(cbind, lapply(result$rclr.tables, function(tbl) {
  tbl[common_samples, , drop = FALSE]
}))
# drop columns with any NA after intersection, just in case
features_rclr_concat <- features_rclr_concat[, colSums(is.na(features_rclr_concat)) == 0, drop = FALSE]
pca_concat <- prcomp(features_rclr_concat, center = TRUE, scale. = TRUE)
features_concat_pca <- pca_concat$x[, seq_len(min(10, ncol(pca_concat$x))), drop = FALSE]

# 3e) Single-layer RPCA baseline (pick a named layer explicitly)
layer_name <- names(dataset_specific_scores)[1]  # or "microbiota", etc.
features_layer1 <- dataset_specific_scores[[layer_name]][common_samples, , drop = FALSE]

# 3f) Random baseline
features_random <- matrix(runif(n = nrow(features_jointRPCA) * 10), nrow = nrow(features_jointRPCA), ncol = 10)
rownames(features_random) <- common_samples

# 4) Cross-validated evaluation -----------------------------------------------
evaluate_model_cv <- function(features, labels, folds = 5, ntree = 500) {
  # sanity: keep only rows in common
  keep <- intersect(rownames(features), names(labels))
  X <- features[keep, , drop = FALSE]
  y <- droplevels(labels[keep])

  # create stratified folds
  folds_idx <- caret::createFolds(y, k = folds, list = TRUE)
  accs <- numeric(length(folds_idx))
  aucs <- numeric(length(folds_idx))

  for (i in seq_along(folds_idx)) {
    test_idx <- folds_idx[[i]]
    train_idx <- setdiff(seq_len(nrow(X)), test_idx)

    # guard: if a class missing in training fold, skip this fold
    if (length(unique(y[train_idx])) < 2) {
      accs[i] <- NA; aucs[i] <- NA; next
    }

    rf_model <- randomForest(x = X[train_idx, , drop = FALSE], y = y[train_idx], ntree = ntree)

    # accuracy
    pred_class <- predict(rf_model, X[test_idx, , drop = FALSE])
    accs[i] <- mean(pred_class == y[test_idx])

    # AUC: handle binary vs multi-class robustly
    pred_prob <- predict(rf_model, X[test_idx, , drop = FALSE], type = "prob")
    # if binary, pROC::auc accepts vector truth + numeric probs of positive class
    if (nlevels(y) == 2) {
      pos <- levels(y)[2]
      aucs[i] <- tryCatch(
        as.numeric(pROC::auc(response = y[test_idx], predictor = pred_prob[, pos])),
        error = function(e) NA_real_
      )
    } else {
      # macro-average one-vs-all AUC
      cls <- levels(y)
      auc_k <- sapply(cls, function(cl) {
        tryCatch(
          as.numeric(pROC::auc(response = factor(y[test_idx] == cl, levels = c(FALSE, TRUE)),
                               predictor = pred_prob[, cl])),
          error = function(e) NA_real_
        )
      })
      aucs[i] <- mean(auc_k, na.rm = TRUE)
    }
  }

  list(accuracy = mean(accs, na.rm = TRUE),
       auc      = mean(aucs, na.rm = TRUE))
}

# 5) Run evaluations -----------------------------------------------------------
res_joint   <- evaluate_model_cv(features_jointRPCA, labels)
res_rpca    <- evaluate_model_cv(features_rpca_concat, labels)
res_pca     <- evaluate_model_cv(features_pca_concat, labels)
res_cpca    <- evaluate_model_cv(features_concat_pca, labels)
res_layer1  <- evaluate_model_cv(features_layer1, labels)
res_random  <- evaluate_model_cv(features_random, labels)

# 6) Summary table -------------------------------------------------------------
results_df <- data.frame(
  Method   = c("Joint-RPCA (shared)", "Per-layer RPCA (concat)", "Per-layer PCA (concat)",
               "Concat rCLR -> PCA", "Single-layer RPCA", "Random"),
  Accuracy = c(res_joint$accuracy, res_rpca$accuracy, res_pca$accuracy,
               res_cpca$accuracy, res_layer1$accuracy, res_random$accuracy),
  AUC      = c(res_joint$auc, res_rpca$auc, res_pca$auc,
               res_cpca$auc, res_layer1$auc, res_random$auc),
  row.names = NULL
)

print(results_df)

```
